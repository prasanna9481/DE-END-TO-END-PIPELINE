# -*- coding: utf-8 -*-
"""Budget_2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qMzLlF3ZOfGITg1DXHa-RXhOvOcV5fs9

**XGBoost for forecasting**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, RandomizedSearchCV
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error

# Loading the dataset
file_path = "/content/sample_0.01 NN.csv"
df = pd.read_csv(file_path)

# Step 1: Data Preprocessing

# Convert timestamp to datetime and extract week number & year
df['arrival_timestamp'] = pd.to_datetime(df['arrival_timestamp'])
df['week'] = df['arrival_timestamp'].dt.isocalendar().week
df['year'] = df['arrival_timestamp'].dt.year

# Fill missing values
df['queue_duration_ms'].fillna(0, inplace=True)
df['execution_duration_ms'].fillna(0, inplace=True)
df['mbytes_scanned'].fillna(0, inplace=True)
df['mbytes_spilled'].fillna(0, inplace=True)
df['compile_duration_ms'].fillna(0, inplace=True)

# Compute Cost Metrics
df['compute_cost'] = ((df['queue_duration_ms'] + df['execution_duration_ms']) / 1000) * 0.00006944
df['storage_cost'] = ((df['mbytes_scanned'] + df['mbytes_spilled']) / 1024) * 0.02
df['total_cost'] = df['compute_cost'] + df['storage_cost']

# Step 2: Aggregate data weekly
weekly_data = df.groupby(['year', 'week']).agg({
    'execution_duration_ms': 'sum',
    'queue_duration_ms': 'sum',
    'compile_duration_ms': 'sum',
    'mbytes_scanned': 'sum',
    'mbytes_spilled': 'sum',
    'num_joins': 'mean',
    'num_scans': 'mean',
    'num_aggregations': 'mean',
    'total_cost': 'sum'
}).reset_index()

# Step 3: Feature Selection
weekly_features = [
    'execution_duration_ms', 'compile_duration_ms', 'queue_duration_ms',
    'mbytes_scanned', 'mbytes_spilled', 'num_joins', 'num_scans', 'num_aggregations'
]

# Fill missing values in selected features
weekly_data[weekly_features] = weekly_data[weekly_features].fillna(0)

# Step 4: Splitting Weekly Data
X_weekly = weekly_data[weekly_features]  # Features
y_weekly = weekly_data['total_cost']  # Target variable

X_train_w, X_test_w, y_train_w, y_test_w = train_test_split(X_weekly, y_weekly, test_size=0.2, random_state=42)

# Step 5: Hyperparameter Tuning to Avoid Overfitting
rf_tuned = RandomForestRegressor(random_state=42)

param_grid = {
    'n_estimators': [100, 200, 300],
    'max_depth': [10, 15, 20],
    'min_samples_split': [5, 10, 15],
    'min_samples_leaf': [2, 4, 6]
}

random_search = RandomizedSearchCV(rf_tuned, param_grid, n_iter=10, cv=3, scoring='neg_mean_absolute_error', random_state=42, n_jobs=-1)
random_search.fit(X_train_w, y_train_w)

# Best model from tuning
best_rf_model = random_search.best_estimator_
best_rf_model.fit(X_train_w, y_train_w)

# Step 6: Forecast Next 1 Month Using the Last 3 Months Data
recent_weeks = weekly_data.iloc[-12:]  # Use last 3 months of data
X_recent = recent_weeks[weekly_features]

# Generate next 4 weeks
future_weeks_next_month = []
next_week_start = weekly_data[['year', 'week']].iloc[-1]

for i in range(4):  # Forecast for next 4 weeks
    next_week_start = next_week_start.copy()
    next_week_start['week'] += 1
    if next_week_start['week'] > 52:
        next_week_start['week'] = 1
        next_week_start['year'] += 1
    future_weeks_next_month.append(next_week_start.copy())

# Convert future weeks into DataFrame
future_weeks_next_month_df = pd.DataFrame(future_weeks_next_month)

# Predict Next 4 Weeks Using the Optimized Model
future_predictions_1m = best_rf_model.predict(X_recent.iloc[-4:])

# Assign predictions to future weeks
future_weeks_next_month_df['predicted_cost'] = future_predictions_1m

# Step 7: Visualization of Forecast for the Next Month
plt.figure(figsize=(12, 6))
plt.plot(weekly_data['week'], weekly_data['total_cost'], label="Actual Weekly Cost", marker="o", linestyle="-")
plt.plot(future_weeks_next_month_df['week'], future_weeks_next_month_df['predicted_cost'], label="Forecasted Weekly Cost (Next Month)", marker="x", linestyle="--", color="red")
plt.xlabel("Week Number")
plt.ylabel("Cost ($)")
plt.title("Weekly Cost Forecasting for the Next Month (Optimized Model)")
plt.legend()
plt.grid(True)
plt.show()

# Display best hyperparameters found
random_search.best_params_