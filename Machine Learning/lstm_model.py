# -*- coding: utf-8 -*-
"""LSTM_model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wubPYe8gV-2_PHmQXLbWOLcbrjk6mwUL
"""

# Importing necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from sklearn.preprocessing import MinMaxScaler
from datetime import datetime, timedelta

# Load dataset
file_path = "/content/sample_0.01 new.csv"
df = pd.read_csv(file_path)

# Convert timestamp to datetime format
df['arrival_timestamp'] = pd.to_datetime(df['arrival_timestamp'])

# Aggregate data by month to count queries per month
df_monthly = df.set_index('arrival_timestamp').resample('M').count()['query_id'].reset_index()
df_monthly.rename(columns={'arrival_timestamp': 'ds', 'query_id': 'y'}, inplace=True)

# Normalize the data
scaler = MinMaxScaler()
df_monthly['y_scaled'] = scaler.fit_transform(df_monthly[['y']])

# Dynamically adjust sequence_length based on dataset size
max_sequence_length = 3
available_months = len(df_monthly)
sequence_length = min(max_sequence_length, available_months - 1)
if sequence_length < 1:
    raise ValueError("Not enough data points to create sequences. Dataset must have at least 2 months of data.")
print(f"Using sequence_length={sequence_length} based on available months={available_months}")

# Prepare data for LSTM
def create_sequences(data, seq_length):
    sequences, labels = [], []
    for i in range(len(data) - seq_length):
        sequences.append(data[i:i + seq_length])
        labels.append(data[i + seq_length])
    return np.array(sequences), np.array(labels)

X, y = create_sequences(df_monthly['y_scaled'].values, sequence_length)
if X.shape[0] == 0:
    print("⚠️ Warning: Not enough data for training. Consider reducing sequence_length further.")
    sequence_length = max(1, sequence_length - 1)
    X, y = create_sequences(df_monthly['y_scaled'].values, sequence_length)
if X.shape[0] == 0:
    raise ValueError("Sequence creation failed after adjustment. Dataset is too small.")
X = X.reshape((X.shape[0], X.shape[1], 1))  # Reshape for LSTM

# Split data into training and testing
train_size = max(1, int(len(X) * 0.8))  # Ensure at least one training sample
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

if len(X_train) == 0 or len(y_train) == 0:
    raise ValueError("No training data available. Ensure dataset has enough records.")

# Build LSTM Model
model = Sequential([
    LSTM(50, return_sequences=True, input_shape=(sequence_length, 1)),
    Dropout(0.2),
    LSTM(50, return_sequences=False),
    Dropout(0.2),
    Dense(25),
    Dense(1)
])

# Compile model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train model
model.fit(X_train, y_train, epochs=50, batch_size=1, validation_data=(X_test, y_test) if len(X_test) > 0 else None)

# Predict next month's query count
last_sequence = df_monthly['y_scaled'].values[-sequence_length:].reshape(1, sequence_length, 1)
next_month_scaled = model.predict(last_sequence)
next_month_pred = scaler.inverse_transform(next_month_scaled.reshape(-1, 1))[0][0]

print(X_train.shape)

# Generate sinusoidal visualization
time_values = np.linspace(0, len(df_monthly), len(df_monthly))
sinusoidal_curve = np.sin(time_values) * (df_monthly['y'].max() - df_monthly['y'].min()) / 2 + df_monthly['y'].mean()

plt.figure(figsize=(10, 5))
plt.plot(df_monthly['ds'], df_monthly['y'], label='Actual Queries', marker='o')
plt.plot(df_monthly['ds'], sinusoidal_curve, label='Sinusoidal Fit', linestyle='dashed')
future_date = df_monthly['ds'].max() + timedelta(days=30)
plt.scatter([future_date], [next_month_pred], color='red', label='Predicted Next Month')
plt.xlabel("Time")
plt.ylabel("Number of Queries")
plt.title("Monthly Query Count Forecasting with Sinusoidal Fit")
plt.legend()
plt.show()

# Generate insights
trend_diff = df_monthly['y'].diff().mean()
trend = "increasing" if trend_diff > 0 else "decreasing"
print(f"Predicted query count for next month: {next_month_pred:.2f}")
print(f"Trend Analysis: The overall trend is {trend} with an average monthly change of {trend_diff:.2f} queries.")